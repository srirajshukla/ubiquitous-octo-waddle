from fastapi import APIRouter
import datetime
import secrets
from typing import Union, Annotated, List, Literal
import uuid

import repository.db as db
import model.saved_file as SF
from llm.genpdf import create_pdf_with_answers

from fastapi import Body, FastAPI, Form, UploadFile, File, Depends, HTTPException, status, BackgroundTasks
from fastapi.security import HTTPBasic, HTTPBasicCredentials
from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel, ValidationError, Field, model_validator
from sqlalchemy.orm import Session

import llm.training as llmtraining
from dotenv import load_dotenv
import os
load_dotenv()

router = APIRouter()

security = HTTPBasic()

def get_current_username(
    credentials: Annotated[HTTPBasicCredentials, Depends(security)]
):
    current_username_bytes = credentials.username.encode("utf8")
    print(os.getenv("USER_USERNAME"))
    correct_username_bytes = os.getenv("USER_USERNAME").encode("utf8")
    is_correct_username = secrets.compare_digest(
        current_username_bytes, correct_username_bytes
    )
    current_password_bytes = credentials.password.encode("utf8")
    correct_password_bytes = os.getenv("USER_PASSWORD").encode("utf8")
    is_correct_password = secrets.compare_digest(
        current_password_bytes, correct_password_bytes
    )
    if not (is_correct_username and is_correct_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Basic"},
        )
    return credentials.username


@router.get("/ping")
def get_ping():
    return {"ping": datetime.datetime.now()}


def upload_file_bg_task(db: Session, filepaths, user, trackingid, year):
    status = llmtraining.pdf_loader(filepaths, year=year)
    for file in filepaths:
        out = SF.update_savedfile(db, file, user, year, trackingid, "DONE")
        print(out)
    print(status)

from io import BytesIO, BufferedReader
import repository.azure_storage as azstore

@router.post("/esgreports/upload")
async def upload_files(
    documentName: Annotated[list[UploadFile], File()],
    DocumentURL: Annotated[list[str], Form()],
    year: Annotated[str, Form()],
    background_tasks: BackgroundTasks,
    db: Session = Depends(db.get_db),
    user: str = Depends(get_current_username),
):
    print(documentName)
    DocumentURL = DocumentURL[0].split(",")
    print(DocumentURL)

    trackerid = str(uuid.uuid4())
    status = "IN PROGRESS"
    filepaths = []
    for file, url in zip(documentName, DocumentURL):
        with open(file.filename, "wb") as out_file:
            content = file.file.read()
            out_file.write(content)
            azstore.upload_blob_to_container(content, file.filename, year, blobstore="fileuploads")
            SF.create_savedfile(
                db, year, file.filename, url, "training", user, trackerid
            )
            filepaths.append(file.filename)

    background_tasks.add_task(upload_file_bg_task, db=db, filepaths=filepaths, user=user, trackingid=trackerid, year=year)
            
    return {"status": status, "message": "uploaded files", "trackerid": trackerid}


class ReportYear(BaseModel):
    year: str


@router.post("/esgreports/retrieve")
def retrieve_files(
    report_year: ReportYear,
    db: Session = Depends(db.get_db),
    user: str = Depends(get_current_username),
):
    files = SF.get_savedfile(db, report_year.year, user)
    print(files)
    ans = []
    for file in files:
        docs = {"filename" : file.filename}

        metadata = {
            "documentType": "PDF",
            "referenceLink": file.url,
            "generated By": file.user,
            "reportYear": file.year,
        }

        docs["metadata"] = metadata
        ans.append(docs)


    return {"documents": ans}

import json
class Metadata(BaseModel):
    generateReportForYear: str = Field(...)
    userId: str = Field(...)

    @model_validator(mode="before")
    @classmethod
    def validate_to_json(cls, value):
        if isinstance(value, str):
            return cls(**json.loads(value))
        return value

def checker(data: str = Form(...)):
    try:
        return Metadata.model_validate_json(data)
    except ValidationError as e:
        raise HTTPException(
            detail=jsonable_encoder(e.errors()),
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        )

import llm.genpdf as genpdf

def generate_report(db: Session, filepath, user, trackingid, year):
    outputstr = f"outfile-{year}.pdf"
    genpdf.create_pdf_with_answers(year, filepath, outputstr)
    out = SF.update_savedfile(db, filepath, user, year, trackingid, "DONE")
    print(out)


@router.post("/questionnaire/generatefirstdraft/pdf")
def generate_first_draft(
    SurveyQuestionnaireDocumentName: Annotated[UploadFile, File()],
    documentType : Annotated[Literal['PDF', 'XLS'], Form()],
    background_tasks: BackgroundTasks,
    metadata: Metadata = Body(...),
    db: Session = Depends(db.get_db),
    user: str = Depends(get_current_username),
):
    print(metadata)
    trackerid = str(uuid.uuid4())
    with open(SurveyQuestionnaireDocumentName.filename, "wb") as out_file:
        content = SurveyQuestionnaireDocumentName.file.read()
        out_file.write(content)
        SF.create_savedfile(
                db, metadata.generateReportForYear, SurveyQuestionnaireDocumentName.filename, SurveyQuestionnaireDocumentName.filename, "Questionnaire", user, trackerid
            )
    background_tasks.add_task(generate_report, db=db, filepath=SurveyQuestionnaireDocumentName.filename, user=user, trackingid=trackerid, year=metadata.generateReportForYear)
    return {"taskid": trackerid, "status": "processing", "createdAt": datetime.datetime.now()}


@router.get("/questionnaire/generatefirstdraft/pdf/{reportYear}/{TaskId}/status")
def get_draft_status(
    reportYear,
    TaskId,
    db: Session = Depends(db.get_db),
    user: str = Depends(get_current_username),

):
    file = SF.get_taskid_status(db, TaskId, user, reportYear)
    if file is None:
        raise HTTPException(status_code=400, detail="Malformed request")
    return {"taskid": file.trackerid, "status": file.embed_status, "created": datetime.datetime.now()}

from requests_toolbelt import MultipartEncoder
from fastapi.responses import Response, FileResponse

@router.get("/firstdraftreport/download/result/{reportYear}")
def get_draft_report(reportYear, 
    db: Session = Depends(db.get_db),
    user: str = Depends(get_current_username)
                     ):
    outputpdf = "/home/chandan/orange/code/survey_report/output.pdf"
    inputpdf = f"/home/chandan/orange/code/survey_ques/{reportYear}.pdf"
    outputpdffilename = f"outfile-{reportYear}.pdf"
    document_path = f"https://team50filestorage.blob.core.windows.net/reports/{reportYear}/{outputpdffilename}"
    with open(outputpdffilename, 'rb') as out:
        azstore.upload_blob_to_container(out.read(), outputpdffilename, reportYear, blobstore="reports")
    docs = {"filename" : outputpdffilename}
    metadata = {
        "documentType": "PDF",
        "referenceLink": document_path,
        "generated By": user,
        "reportYear": reportYear,
    }

    docs["metadata"] = metadata

    # m = MultipartEncoder(
    #         fields = {'documents': [docs]}
    # )
    return {"documents": [docs]}

class QuestionAnswer(BaseModel):
    reportYear: str
    inputQuestion: str


class QuestionAnswerResult(BaseModel):
    reportYear: str

import llm.questionnaire as llmquestions

@router.post("/questionnaire/generatefirstdraft/generateAnswer")
def question_answer(question: QuestionAnswer,
    db: Session = Depends(db.get_db),
    user: str = Depends(get_current_username)):
    all_years = SF.get_all_years(db, user)
    response = llmquestions.query(question.inputQuestion, question.reportYear, all_years)
    return {
        "reportYear": question.reportYear,
        "questionnaireSummary": {
            "response": response,
            "status": "success",
            "citation": "this page",
            "documentRef": "page 1",
            "accuracy": "0.8",
            "confidence": "0.8",
        },
    }
